1. Set, Map

    Set, Map

    해시 테이블 구조를 기반으로 하는 자료구조 중 한 종류
    해시값(암호화 된 값)으로 키와 값을 바꾸어 저장하여 데이터 검색과 추가에 용이하게 설계
    특히, 일일히 값을 비교하여 찾지 않고, 해쉬된 값을 비교하기 때문에 검색하는 시간이 엄청 빠릅니다.

    ex) 3000개의 길이를 갖는 배열에서 특정 값이 있는지 찾기 위해서는 시간 소요가 오래 걸립니다.
        그러나, 해쉬 데이터 구조를 참조했을 때는 수십배는 빠른 속도로 데이터를 찾아낼 수 있음.

    Map
        키가 있는 값을 저장하는 것은 객체와 유사
        그러나 Map은 문자열이 아닌 다양한 자료형을 키 값으로 허용할 수 있음

        ex) 
        (Object)
        {
            1: 안녕하세요
        }
        -------------------
        (Map)
        [[{}, 안녕하세요], []]
        -------------------

        const 변수명 = new Map()
        변수명.set(key, value) // 키와 값을 추가
        변수명.has(key) // 해당 키의 데이터가 있는지 검사 (T/F)
        변수명.delete(key) // 해당 키의 데이터 삭제
        변수명.clear() // 모든 데이터 삭제
        변수명.size() // 현재 가지고 있는 키의 갯수
        -------------------

    Set
        중복을 허용하지 않는 값을 모아놓은 객체와
        Set에는 키가 없는 값이 저장
        이터러블한 객체를 Set으로 변형시켜 사용 ex) 배열 -> Set -> 중복된 요소를 제거하기 위해서

        ex)
            let setTable = new Set([1,1,2,2,3,3,4,5,5])
            console.log(setTable) [1,2,3,4,5](x) -> Set(1,2,3,4,5) -> array(Array.from)

        -------------------

        set.add(value)
        set.delete(value)
        set.clear()
        set.size()

        -------------------

    Object vs Map, Set(자료형)

        1. 단순한 string과 같은 데이터를 사용할 때에는 Object가 낫습니다.
        2. Set은 중복된 요소를 삭제할 때는 무조건 Set을 사용해야한다.
        3. Map은 데이터 크기가 클 수록 (대용량의 데이터) 성능이 좋아집니다. (삭제, 검색)
        4. 3000개의 이름 중에서 특정한 이름이 있는지 없는지 여부를 판단해야 한다? -> Map, Set || Object    

        -------------------

2. Promise, async, await, 비동기

        자바스크립트의 스레드 (일꾼)

        a .. (3초)
        b .. (2초)
        c .. (10초)
        d .. (8초)
        ----------------(23초)

        의도, 설계 

        a -> b -> c -> d (23초)

        a - > b (5초)
        c   (10초)
        d   (8초) ----- (10초)

        -------------------

        자바스크립트는 싱글스레드이기 때문에 의도와 상관없이 모두 23초를 기다려야합니다.
        그러나 이는 병목 현상을 유발 할 수 있고 오랜 시간 사용자가 기다려야할 수 있습니다.

        자바스크립트는 이를 해소하기 위해 비동기 실행 방식을 선택하였고
        비동기는 시간이 오래 걸릴 수 있는 함수를 따로 정의(setTimeout, Promise, ...)
        (비동기 함수)하여 병렬적으로 자바스크립트를 실행할 수 있도록 하였다

        -------------------

        비동기의 처리 방식과 비동기 처리

        a(2초) -> b(3초) -> e(3초) - 동기(순차적으로)
        c(10초) -> 비동기(순차적이지 않은, 동시에)
        d(8초) -> 비동기    

        3초의 시간이 걸리는 e의 로직이 추가되었는데 e는 a,b와는 상관이 없으며
        c가 반드시 끝나고 난후에 실행해야 한다.

        그러나, 자바스크립트에서 비동기 함수와 동기 함수는 따로 구분되어있음
        이 경우 어떻게 해야할까?

        1. callback
            더이상 사용하지 않아요. 이유는 callback에 callback이 일어나는
            callback 지옥 현상

        2. promise then catch
            근래까지 많이 사용되는 패턴이었지만 async await의 등장으로 사용이 많이 줄어듬

        3. async await
            현재 가장 많이 사용하는 비동기 처리 로직으로 특정한 함수를 동기 비동기 로직이 함께 있는 상태로
            비동기 함수로 만들어버립니다.

        => 비동기가 끝나고 실행햐야하는 함수가 있는데 (비동기의 값이 필요하기 때문)
           자바스크립트는 비동기와 동기가 구분되어있기에 함께 사용이 불가능하여 이를 함께 사용하기 위해
           비동기 처리가 등장하였다

    ------------------------------------------------------------------------------------
